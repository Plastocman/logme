from ast import parse, NodeTransformer, Name, Store, fix_missing_locations


def tree_factory(template, **identifiers):
    """
    injects variable into the code template to generate source code
    returns the ast generated by the parsed source code

    :param: string: template: the source code you want to parse
    :param: dict identifiers: the variables you want to inject in your template

    :rtype: ast.Node
    :returns: an list containing 1 ast subtree, corresponding to the
        parsed code template. The fact that it returns a list of 1 element
         makes it handy to concatenate with other ast nodes, that appear
         as a list of statements.

    Example:
        template = "x = {my_var} + y + 2"
        identifiers = {'my_var' : 'y'}
        x = tree_factory(template, **identifiers)
        print ast.dump(x[0])

        this will return the following ast node :
        Assign(targets=[Name(id='x', ctx=Store())],
               value=BinOp(left=BinOp(left=Name(id='y', ctx=Load()),
                                      op=Add(),
                                      right=Name(id='y', ctx=Load())
                                      ),
                           op=Add(),
                           right=Num(n=2)
                          )
               )



    """
    source = template.format(**identifiers)
    return parse(source).body


# This is the template to generate the code to inject
# to log every caught exception with its traceback
# don't mind the stupid file name, it's only here to avoid name conflicts
logging_statement = """import traceback
val = traceback.format_exc()
with open('{log_file}', 'a') as plz_be_a_free_name:
    plz_be_a_free_name.write('New caught error : \\n {{}} \\n'.format(val))"""


class LogExceptions(NodeTransformer):
    """
    This is the class that will visit and modify the syntax tree.
    It will call `visit_ExceptHandler` when it hits an ExceptHandler ast Node
    and add a logging instruction below it. It will apply an in-place
    modification of the parse treee through the `visit_ExceptHandler` callback
    """

    def __init__(self, package, log_file, *args, **kw):
        """The `NodeTransformer` class has no need to call
        __init__ apprently"""
        self.log_code = logging_statement
        self.log_file = log_file

    def visit_ExceptHandler(self, node):
        """This is the main method
        it adds a logging statement after each except handler in
        your code abstract syntax trees"""

        # does the node have a name for the caught exception ?
        try:
            exc_id = node.name.id
        # if not, give one because we need a handle on the exception
        except AttributeError:
            exc_id = 'ast_exc_id'
            node.name = Name(id=exc_id, ctx=Store())

        # first we generate the ast node to inject
        log_node = tree_factory(self.log_code, log_file=self.log_file)

        # and we simply add it to the except handler body
        node.body = log_node + node.body

        # needed to fix line numbers
        fix_missing_locations(node)
        return node
